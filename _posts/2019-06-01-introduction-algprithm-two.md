---
layout:     post
title:      "算法导论笔记（下）"
subtitle:   "持续更新。。。"
date:       2019-06-01
author:     "JohnReese"
header-img: "img/post-bg-js-version.jpg"
mathjax: True
tags:
    - Algorithm
---

笔记对应的课程为：[https://www.bilibili.com/video/av48922404/?p=3](https://www.bilibili.com/video/av48922404/?p=3)
其中本网页包含视频中的11~21集内容。

## 目录
1. [动态有序统计&区间树](#动态有序统计&区间树)
2. [跳跃表](#跳跃表)
3. [平摊分析](#平摊分析)

## 11. 动态有序统计&区间树
> 英文：Dynamic Order Statistics & Interval Tree

#### 动态有序统计
1. 功能：
    * 返回当前集合的第`i`小的数
    * 返回`x`在当前集合的排名（`Rank`)
    * 插入操作
    * 删除操作（之后忽略不讲。。。）
2. 构造方法：基于红黑树，并在每个节点上多记录一项信息：每个节点所包含的子树的大小（包括其本身）。`|`我觉得看到这里基本就可以预见如何来编写功能的第1和第2条了。剩下的就是如何在原有的插入和删除操作的更新过程中维护额外的子树大小的信息。
3. 功能1的伪代码，其中`x`是当前节点，`size`是子树大小，`OS-Select(x, i)`是函数名：
    ```
    k = size[left[x]] + 1
    if i == k then return x
    if i < k then return OS-Select(left[x], i)
             else return OS-Select(right[x], i - k)
    ```
    其实在尝试的过程中可以发现上述代码中的`k`代表了节点`x`的秩（`Rank`）。所以功能2的实现就很显然了，通过平衡树的性质快速地找到`x`，然后直接返回`size[left[x]] + 1`。
4. 插入的实现：
    * 在最开始的确定位置（叶子节点）的过程中，对于每个经过的节点的`size`进行加一操作
    * 再使用红黑树的分类讨论的更新操作，并且你会发现通过保留子树大小而不是直接保留每个节点的秩使得我们在更新操作的时候基本上不需要费心考虑如何维护它。
5. 从动态有序统计总结扩充数据结构功能的一般原则：
    * Choose underlying data structure(e.g. red-black tree)
    * Determine additional information(e.g. subtree size)
    * Verify information can be maintained for modifying operations(e.g Insertion, Delete, Rotation)
    * Develop new operations that use info(e.g. OS-Select)

#### 区间树
1. 特点及操作：
    * 维护区间的集合，其中每个节点保存一段区间
    * 查找给定区间重叠的区间
    * 以区间的低端点(`low end point`)来作为顺序的定义。即左端点小的代表整段区间小。
    * 每个节点额外维护的信息是其子树中所包含的所有区间中最大的`m`。其中`m`是每个区间的右端点(`high end point`)的大小。所以$m = max(high[int[x]]], m[left[x]], m[right[x]])$
2. 插入的实现：和`DOS`差不多，都是在向下确定位置的时候就更新路过的每个节点的`m`的大小。
3. `Interval-Search(i)`的伪代码实现:
    ```
    x = root
    while x != null and (low[i] > high[x] or high[i] < low[x])
    do
        if left[x] != null and low[i] <= m[left[x]]
            then x = left[x]
            else x = right[x]
    return x
    ```
    让我们来解读一下伪代码，其中循环的条件是当前节点`x`非空，且`i`表示的区间与当前`x`所表示的区间没有重叠。（但我有个点没有弄明白，就是重叠的话就直接返回当前的`x`了，但是`x`的子树中也有可能包含覆盖`i`所在的区间。唯一可能的解释是只需要找出其中一个满足的区间即可，但我感觉教授没说，但其实此点很重要）那么先抛开这个疑问不看，继续来看循环中的内容。为什么当`low[i] <= m[left[x]]`时只需要看左子树呢？这里似乎又印证了我对自己疑问的解释，即当左子树中最大的右端点已经确定比`low[i]`大了，那么我们要做的就是找到尽量小的左端点来与区间`i`重叠。这是我自己的理解。


## 12. 跳跃表
> 英文：Skip Lists

1. 跳跃表也是维护一个动态有序集合，以很大概率接近`O(logN)`的时间复杂度找到一个数、插入或删除。其核心是通过多个邻接表来表示一个有序的集合。
2. 教授提了一个非常秀，非常真实的例子：美国纽约地铁。我们也按照相同的顺序来介绍跳跃表。
    * 地铁分为两条线：快线和慢线。其中快线之所以快是因为它只包含这条线路的几个站台，如下所示
    * 快线：14，，，，，34，，42，，，，，，，，，，，72，，，，
    * 慢线：14，，23，，34，，42，，50，，59，，69，，72，，79
    * 比如乘客要从14到69，那么最快的应该是快线到72然后往回乘到69。但是程序不会这样往回走，它会直接在快线找到72意识到走过了，然后在快线往回通过42到慢线再往右到达69。所以跳跃表的核心就是通过多建邻接表来节约搜索的时间。
3. 我们先来做一个递推的假设，我们肯定需要一个邻接表记录所有的元素。当我们新建额外的一个邻接表时，如何对它进行设计可以使得搜索的时间复杂度尽量小？
    * 直觉告诉我们肯定是平均建站。也就是假设我们建`n`个快站且总共有`N`个站，则搜索的时间复杂度约等于$n + \frac{N}{n}$。那么我们很容易地看出或通过求导得出$n = 2 \cdot \sqrt{N} = 2 \cdot N^{\frac{1}{2}}$。
    * 但这样的时间复杂度还远远达不到我们想要的，那么我们继续新建线路，通过直觉我们能得出当我们拥有`m`条线路时，搜索的时间复杂度最优能达到$O(m \cdot N^{\frac{1}{m}}$。那么什么时候能达到每步的操作在`lgN`级别呢？
    * 答案是建立$\log_2 N$条线路，每步的时间复杂度是$2 \cdot \log_2 N$。这时候的跳跃表长什么样呢？
    * 1，，，，，，，，，，，，，，，，，，，，9
    * 1，，，，，，，，，，5，，，，，，，，，9
    * 1，，，，，3，，，，5，，，，，7，，，，9
    * 1，，2，，3，，4，，5，，6，，7，，8，，9
    * 就像个二叉树。就是维护的地方不太像。。。
4. 搜索操作不用说了，那跳跃表是如何自动维护这么优雅的结构呢？——**概率**。
    * 简单来说，当插入一个元素时，完整的邻接表中肯定是要插入的。然后你开始`掷硬币`，如果是正面就在上面的邻接表中也添加此元素，直到出现一次反面或所有的邻接表都有了此元素。
    * 非常神奇，但是通过严格的证明可以得到这样维护的跳跃表几乎很大的概率都是以`lgN`的时间复杂度来完成每一次操作的。

## 13.平摊分析
> 英文：Amortized Analysis

1. 个人人为本节课比较简单，其主要思想只有一个：将复杂度较高的操作均匀地分配到每次操作中可以使得整体的时间复杂度不会受到较大的影响。
2. 教授从哈希表的扩增说起，比如说表用着用着满了，需要扩增来保持其可用性或保证它的效率。那么就在它满的时候对其扩增。如下所示：
    * 1 未满 [1]
    * 2 满了，扩增一倍 [1, 2]
    * 3 满了，扩增一倍 [1, 2, 3, ] 注意到3后面还有个空位
    * 4 未满 [1, 2, 3, 4]
    * 5 满了，扩增一倍 [1, 2, 3, 4, 5, , , ] 注意到5后面还有3个空位
    * 。。。以此类推
    * ------------------------------`我是分割线`------------------------------
    * 那么最坏情况下的一步操作是$O(n + 1)$，即包括复制和插入。如果进行`n`次就会得出扩增会达到$O(n^2)$的时间复杂度。但事实真的如此吗？
    * 当然不是，因为只有在2次幂左右时才做了这样的一次操作。所以真正的时间复杂度是$\theta(3 \cdot n)$。
3. 结论：1次或多次的高时间复杂度的操作平摊到每个操作上实际可能是低时间复杂度的操作。
4. 其中记账法(`Accounting`)和势能法(`potential`)是用来精确得出平摊后每步的实际操作所消耗的时间。比如扩表的每步操作的花费是`3`。
5. 但我觉得这不是很重要，也比较简单，而且我也有点困了，就不详细写了。因为我觉得只要能计算出实际的整体时间复杂度就`OK`了。
