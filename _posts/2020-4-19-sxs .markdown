---
layout:     post
title:      "东方欲晓，莫道君行早"
subtitle:   "深度学习入门级硕士的算法实习生招聘体会"
date:       2020-4-19 00:00:00
author:     "WuXin"
header-img: "img/2021-4-19/xjcy.jpg"
tags:
    - 面经
    - 算法实习生
---

# 总结
## 个人情况
无论文、非深度学习研究方向、无ACM算法经历

## 面试情况
公司|职位|情况
--|:--|:--
微软|冬季NLP|三轮挂
字节跳动|抖音后端|两轮挂
招行信用卡|模型研发|笔试挂
腾讯|NLP|简历挂
猿辅导|Python|2轮
美团|测开|offer（2+1）
字节跳动|用户增长后端|三轮挂
英特尔|深度学习|offer（2）
网易|AI|笔试挂
OPPO|机器学习|offer（1+1）
百度|推荐算法|一轮挂
阿里|机器学习|offer（5+1）
微软|SWE|等待第三轮

## 一些感受
+ 时间。实习生招聘2月底就有公司开始，因此越早投就越早被发起，HC也就越充裕。

+ 岗位选择。选择项目经验丰富的岗位，不必死磕后端岗。客户端、测开岗对项目要求不高，更偏重基础；对简历对应项目或经验较欠缺而且时间有限的可以选择；竞争激烈程度也相对低很多；另外也可以选择作为保底offer。我是在遭遇字节冬季后端实习生失败后，选择美团测开作为保守底线。之后字节夏季经过三轮面试失败，转岗被捞后再次失败，我明白自己缺乏后端项目的支持。因此转向算法岗。

+ 内推。寻求校友、朋友的资源将事半功倍。

# 面经
我总结和copy了一些面经。除此之外，应准备简历中项目对应的算法的详细方法、论文细节，可能还会被问到需要设计算法方案的场景题。网课资源推荐Coursera上的Deep Learning和机器学习。

## 神经网络

### 激活函数 
如果不用激活函数的话，无论神经网络有多少层，输出都是输入的线性组合。引入非线性、增强整个网络的表征能力。
### 过拟合
+ 方法：正则化、准备更多数据比如数据扩增：有翻转、裁剪、扭曲还有early stopping提早停止梯度下降，预防参数达到很大。进行特征筛选，减少特征数量。

+ **L2正则化**。通过在损失函数中添加权重正则项，反向传播时使得W系数小于1，权重衰减，减弱部分隐层单元的影响，从而简化网络。L2正则化的导数在W>1时更大，l2下降更快，W<1时更小，下降更慢。l2是每次乘上一个小于1的倍数进行收敛，而l1是每次减去一个常数的线性收敛。所以l1更容易收敛到0而 l2只能收敛到比较小的值。
+ dropout 随即失活遍历每一层，设置消除网络中节点的概率，精简网络。使得单元不能依靠任何特征，因为特征都有可能被随机清除。这样会导致权重被收缩，从而达到预防过拟合的效果。

### 激活函数比较
+ 第一，在的区间变动很大的情况下，激活函数的导数或者激活函数的斜率都会远大于0，在程序实现就是一个if-else语句，而sigmoid和tanh函数需要进行浮点四则运算，在实践中，使用ReLu激活函数神经网络通常会比使用sigmoid或者tanh激活函数学习的更快。

+ 第二，sigmoid和tanh函数的导数在正负饱和区的梯度都会接近于0，这会造成梯度弥散，而Relu和Leaky ReLu函数大于0部分都为常数，不会产生梯度弥散现象。(同时应该注意到的是，Relu进入负半区的时候，梯度为0，神经元此时不会训练，产生所谓的稀疏性，而Leaky ReLu不会有这问题)

+ 但是，有足够的隐藏层使得z值大于0，所以对大多数的训练数据来说学习过程仍然可以很快。

+ 快速概括一下不同激活函数的过程和结论。
   * sigmoid激活函数：除了输出层是一个二分类问题基本不会用它。

   * tanh激活函数：tanh是非常优秀的，几乎适合所有场合。

   * ReLu激活函数：最常用的默认函数，如果不确定用哪个激活函数，就使用ReLu或者Leaky ReLu。

### 随机初始化
如果初始化为0，各个隐层单元的函数无论怎样迭代，都是一样的。这样，这些隐层单元的数量就没有了意义。随机初始化通常初始为一个很小的数，如果w很大，这样使得Z很大，如果使用tanh或sigmoid函数，就能处在函数的较平坦位置，使得梯度下降龟速。

### 归一化输入
零均值、归一化方差使得代价函数像个更圆的球形轮廓、使得梯度下降更快。

### 梯度消失、梯度爆炸
+ W参数与单位矩阵差距大时，或使用了不正确的激活函数时。层数增多的时候，因为反向传播的连乘效应最终的求出的梯度更新将以指数形式增加，即发生梯度爆炸，如果此部分小于1，那么随着层数增多，求出的梯度更新信息将会以指数形式衰减，即发生了梯度消失。可以通过权重初始化合理值或使用relu激活函数等。

+ 梯度爆炸的应对方案：
梯度裁剪（gradient clipping）：如果梯度的范数大于某个给定值，将梯度同比收缩

+ 梯度消失的应对方案：
   * 合理的初始化权重值。初始化权重，使每个神经元尽可能不要取极大或极小值，以躲开梯度消失的区域。
   
   * 使用relu代替sigmoid和tanh作为激活函数。
   
   * 使用其他结构的RNNs，比如长短时记忆网络（LTSM）和Gated Recurrent Unit（GRU）

### 优化算法
+ momentum动量梯度下降法使用指数加权平均梯度，减少梯度下降的幅度，还有可能跳出局部最优解，因为当在局部最优解时，仍存在走出这个点的动量。

+ RMSprop能减少在某个方向上的偏移，消除摆动。

+ 学习率衰减。在学习初期，你能承受较大的步伐，但当开始收敛的时候，小一些的学习率能让你步伐小一些。

### batch norm
+ 归一化起的作用的原因，直观的一点就是，它在做类似的工作，但不仅仅对于这里的输入值，还有隐藏单元的值.把学习问题的轮廓，从很长的东西，变成更圆的东西，更易于算法优化。

+ Batch归一化减少了输入值改变的问题，它使这些值变得更稳定，神经网络的之后层就会有更坚实的基础。即使使输入分布改变了一些，它会改变得更少。它做的是当前层保持学习，当改变时，迫使后层适应的程度减小了，你可以这样想，它减弱了前层参数的作用与后层参数的作用之间的联系，它使得网络每层都可以自己学习，稍稍独立于其它层，这有助于加速整个网络的学习。其从神经网络后层之一的角度而言，前层不会左右移动的那么多，因为它们被同样的均值和方差所限制，所以，这会使得后层的学习工作变得更容易些。

+ 使得在mini-batch上增加了一些噪声，有一定的正则化作用。

### 数据集分布不平衡
+ 扩大数据集，增加小类数据。或放弃一部分大类数据。

+ 尝试不同的分类方法，比如决策树。对小类错分进行加权惩罚。

+ 重构分类器。将大类拆分成小类，训练多个分类器，联合起来。

10. 验证集与测试集
训练集用于训练，验证集用于调参数，然后反复迭代直到满足性能。验证集扮演的就是一个辅助模型增加泛化能力的作用。而测试集不同，它仅仅用于最后评估模型的性能。

## CNN
### CNN相比传统全连接的优点
参数共享、稀疏连接


### 池化的作用
+ 缩减模型的大小，减少过拟合，提高计算速度，同时还能保持一定程度的旋转和平移不变性。
+ 最大池化与平均池化：当特征中的信息都具有一定贡献的时候使用AvgPooling，比如网络走到比较深的地方，这个时候特征图的H W都比较小，包含的语义信息较多。为了减少无用信息的影响时用maxpool，比如网络浅层常常见到maxpool，因为开始几层对图像而言包含较多的无关信息。

### Resnet
深层神经网络学习起来很困难。残差块中的跳跃连接能够让下一层学习恒等函数非常容易，网络性能不会受到影响很多时候甚至可以提高效率，因此创建类似残差网络可以提升网络性能。

### 1X1卷积
一般可以做降维或升维，不改变长宽而改变通道数。1*1的卷积在前一层的学习表示上添加了非线性激励（ non-linear activation ），提升网络的表达能力。


## RNN
### RNN和LSTM、GRU对比
+ RNN受到短期记忆的影响。如果序列很长，他们将很难将信息从较早的时间步传送到后面的时间步。因此，如果你尝试处理一段文本进行预测，RNN可能会遗漏开头的重要信息。在反向传播期间，RNN存在梯度消失的问题（梯度用于更新神经网络权重的值）。获得小梯度更新的层会停止学习。RNN会忘记它在较长序列中看到的内容，因此只有短期记忆。

+ LSTM中的门机制可以了解序列中哪些数据重要以进行保留或丢弃。这样，它可以将相关信息传递到长序列中进行预测。

+ GRU的优点是这是个更加简单的模型，所以更容易创建一个更大的网络，而且它只有两个门，在计算性上也运行得更快，然后它可以扩大模型的规模。

### embedding的作用是什么？
Onehot泛化能力不强，词嵌入向量在语义上有意义，比如根据几个词词嵌入余弦相似度来学习到他们的相似性或相异性。

### TF-IDF
tf（Term Frequency）词频：指的是某一个给定的词语在该文件中出现的次数。这个数字通常会被归一化(一般是词频除以文章总词数), 以防止它偏向长的文件。idf（Inverse Document Frequency）逆文档频率：log（语料库的文档总数/包含该词的文档数）

+ 特点：可用某篇文章中出现次数多但在其他文章中出现次数少的词来作为该篇文章的特征词。使罕见的单词更加突出并且有效地忽略了常用单词。易于理解。

+ 缺点：因为是词袋模型，所以没有考虑词的位置信息，但词的位置是有一定含义的。并不能反映单词的重要程度和特征词的分布情况。

### word2vec
推导：。。。
问题：是固定表征的，无法解决一词多义等问题

### word2vec的优化
分级softmax和负采样

### encoder-decoder
不论输入和输出的长度是什么，中间的「向量 c」 长度都是固定的;根据不同的任务可以选择不同的编码器和解码器（可以是一个 RNN ，但通常是其变种 LSTM 或者 GRU ）。c中必须包含原始序列中的所有信息，它的长度就成了限制模型性能的瓶颈。


### attention的原理，计算公式
带权求和。

1. 分三步，第一阶段先计算target中的单词和source中每个单词求相关性或相似性，可以用两个向量点积、cosine相似度或者用额外的神经网络来求值。

2. 第二阶段用softmax函数对第一阶段的得分进行数值转换，一方面可以进行归一化，另一反面可以更加突出重要元素的权重。

3. 第三阶段用权重系数*对应的source作加权求和。

### self attention
引入Self Attention后会更容易捕获句子中长距离的相互依赖的特征，因为如果是RNN或者LSTM，需要依次序序列计算，对于远距离的相互依赖的特征，要经过若干时间步步骤的信息累积才能将两者联系起来，而距离越远，有效捕获的可能性越小。

### transformer
时间片t的计算依赖t-1时刻的计算结果，这样限制了模型的并行能力；
顺序计算的过程中信息会丢失，尽管LSTM等门机制的结构一定程度上缓解了长期依赖的问题，但是对于特别长期的依赖现象,LSTM依旧无能为力。
机器翻译任务中存在源句内部的关系，目标句内部的关系，源句与目标句之间的关系。

## SVM
+ 大间距分类器
+ 核函数：相似度方程来寻找标记点与点的相似度，把相似度作为参数构成非线性边界
